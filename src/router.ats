/*
 * Both the Angular 1.3 Router and Angular 2 Router use this
 */

import RouteRecognizer from 'route-recognizer';

export class Router {
  constructor(parent, configPrefix) {
    this.parent = parent || null;
    this.ports = {};
    this.children = [];
    this.context = null;

    // this is a hack
    var RouteRecognizerConstructor = (RouteRecognizer.default || RouteRecognizer);

    this.recognizer = new RouteRecognizerConstructor();
    this.childRecognizer = new RouteRecognizerConstructor();
  }


  /*
   * constructs a child router
   */
  childRouter() {
    var child = new Router(this);
    this.children.push(child);
    return child;
  }


  /*
   * object to notify of route changes
   */
  registerViewPort(view, name = 'default') {
    this.ports[name] = view;
  }


  /*
   * config
   */
  config(mapping) {
    if (mapping instanceof Array) {
      return mapping.forEach(nav => this.config(nav));
    }
    var handler = mapping.component;

    if (typeof handler === 'string') {
      mapping.handler = { component: handler };
    } else if (typeof handler === 'function') {
      mapping.handler = handler();
    } else if (!mapping.handler) {
      mapping.handler = { component: handler };
    }

    this.recognizer.add([mapping]);

    var withChild = copy(mapping);
    withChild.path += '/*childRoute';
    this.childRecognizer.add([{
      path: withChild.path,
      handler: withChild
    }]);

  }


  /*
   * gets passed a context object
   */
  navigate(url:String) {
    if (url === this.previousUrl) {
      return Promise.resolve();
    }
    this.previousUrl = url;
    var context = this.recognizer.recognize(url);

    if (context == null || context.length < 1) {
      context = this.childRecognizer.recognize(url);
    }

    if (context == null || context.length < 1) {
      return Promise.reject();
    }

    // TODO: not sure if I can compare by identity here
    if (this.context === context[0]) {
      return Promise.resolve();
    }
    this.context = context[0];

    // TODO: not sure what types of things to pass to the handler
    //       the handler should represent a deserialization from params to resources,
    //       but I think this is better owned by the pipeline
    context.component = this.context.handler.component;

    // TODO: this will become the pipeline
    return this.canNavigate(context)
               .then(status => (status && this.activatePorts(context)))
               .then(() => this.previousContext = context);
  }


  /*
   * given a context obj
   * update viewports accordingly
   */
  activatePorts(context) {
    var activations = mapObj(this.ports, port => port.activate(context));

    Promise.all(activations).then(() => {
      if (context[0].params.childRoute) {
        var subNav = '/' + context[0].params.childRoute;
        return Promise.all(this.children.map(child => child.navigate(subNav)));
      }
    });
  }


  /*
   * given a context obj
   * returns a Promise<bool> that represents
   * whether this router and all the descendants can navigate
   */
  canNavigate(context) {
    return Promise.all(this.gatherNagigationPredicates(context))
                  .then(booleanReduction);
  }


  /*
   * given a context obj
   * returns an Array<Promise<bool>> that represents
   * whether this router and all the descendants can navigate
   */
  gatherNagigationPredicates(context) {
    return this.children.reduce(
        (promises, child) => promises.concat(child.gatherNagigationPredicates(context)),
        [this.navigationPredicate(context)]
    );
  }


  /*
   * whether or not this level of router can navigate
   *
   * returns a promise<bool>
   */
  navigationPredicate(context) {
    return Promise.resolve(true);
  }
}

function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function forEach(obj, fn) {
  Object.keys(obj).forEach(key => fn(obj[key], key));
}

function mapObj(obj, fn) {
  var result = [];
  Object.keys(obj).forEach(key => result.push(fn(obj[key], key)));
  return result;
}

function booleanReduction (arr) {
  return arr.reduce((acc, val) => acc && val, true);
}
